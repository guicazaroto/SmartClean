
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/guicazaroto/learning-go/config/auth.go (12.9%)</option>
				
				<option value="file1">github.com/guicazaroto/learning-go/config/config.go (22.2%)</option>
				
				<option value="file2">github.com/guicazaroto/learning-go/config/env.go (0.0%)</option>
				
				<option value="file3">github.com/guicazaroto/learning-go/config/logger.go (36.4%)</option>
				
				<option value="file4">github.com/guicazaroto/learning-go/config/postgres.go (0.0%)</option>
				
				<option value="file5">github.com/guicazaroto/learning-go/handler/cleaner.go (49.7%)</option>
				
				<option value="file6">github.com/guicazaroto/learning-go/handler/handler.go (0.0%)</option>
				
				<option value="file7">github.com/guicazaroto/learning-go/handler/health.go (100.0%)</option>
				
				<option value="file8">github.com/guicazaroto/learning-go/handler/message.go (0.0%)</option>
				
				<option value="file9">github.com/guicazaroto/learning-go/handler/mocks.go (89.7%)</option>
				
				<option value="file10">github.com/guicazaroto/learning-go/main.go (0.0%)</option>
				
				<option value="file11">github.com/guicazaroto/learning-go/model/cleaner_request.go (100.0%)</option>
				
				<option value="file12">github.com/guicazaroto/learning-go/model/message_request.go (100.0%)</option>
				
				<option value="file13">github.com/guicazaroto/learning-go/repository/cleaner.go (0.0%)</option>
				
				<option value="file14">github.com/guicazaroto/learning-go/repository/message.go (0.0%)</option>
				
				<option value="file15">github.com/guicazaroto/learning-go/router/router.go (0.0%)</option>
				
				<option value="file16">github.com/guicazaroto/learning-go/router/routes.go (0.0%)</option>
				
				<option value="file17">github.com/guicazaroto/learning-go/schemas/cleaner.go (100.0%)</option>
				
				<option value="file18">github.com/guicazaroto/learning-go/schemas/message.go (100.0%)</option>
				
				<option value="file19">github.com/guicazaroto/learning-go/util/cors.go (0.0%)</option>
				
				<option value="file20">github.com/guicazaroto/learning-go/util/hash.go (100.0%)</option>
				
				<option value="file21">github.com/guicazaroto/learning-go/util/response.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v4"
)

var jwtKey = map[string][]byte{
        "cleaner": []byte(Environment.CleanerToken),
}

type Claims struct {
        Id   string `json:"cleaner_id"`
        Role string `json:"role"`
        jwt.RegisteredClaims
}

func GenerateJWT(id string, role string) (string, error) <span class="cov8" title="1">{
        expirationTime := time.Now().Add(2 * time.Hour)
        claims := &amp;Claims{
                Id:   id,
                Role: role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expirationTime),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtKey[role])
}</span>

func JWTMiddleware(role string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tokenString := c.GetHeader("Authorization")
                if tokenString == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">claims := &amp;Claims{}
                token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return jwtKey[role], nil
                }</span>)

                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("id", claims.Id)
                c.Set("role", claims.Role)
                c.Next()</span>
        }
}

func AuthTokenMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tokenString := c.GetHeader("Authorization")
                if tokenString == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing token"})
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">if tokenString != Environment.DefaultToken </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import "gorm.io/gorm"

var (
        db     *gorm.DB
        logger *Logger
)

func Init() error <span class="cov0" title="0">{
        var err error
        db, err = InitializePostgres()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error initializing db")
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GetDb() *gorm.DB <span class="cov0" title="0">{
        return db
}</span>

func GetLogger(p string) *Logger <span class="cov8" title="1">{
        logger = NewLogger(p)
        return logger
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "log"

        "github.com/codingconcepts/env"
        "github.com/joho/godotenv"
)

type environment struct {
        PostgresHost        string `env:"POSTGRES_HOST" required:"true"`
        PostgresPort        int    `env:"POSTGRES_PORT" default:"5432"`
        PostgresUser        string `env:"POSTGRES_USER" required:"true"`
        PostgresPassword    string `env:"POSTGRES_PASSWORD" required:"true"`
        PostgresDb          string `env:"POSTGRES_DB" required:"true"`
        AwsRegion           string `env:"AWS_REGION" required:"true"`
        AwsImgProfileBucket string `env:"AWS_IMG_PROFILE_BUCKET" required:"true"`
        DefaultToken        string `env:"DEFAULT_TOKEN" required:"true"`
        CleanerToken        string `env:"CLEANER_TOKEN" required:"true"`
}

var Environment environment

func InitEnvs() <span class="cov0" title="0">{
        err := godotenv.Load(".env")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error loading .env file:", err)
        }</span>

        <span class="cov0" title="0">if err := env.Set(&amp;Environment); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "io"
        "log"
        "os"
)

type Logger struct {
        debug   *log.Logger
        info    *log.Logger
        warning *log.Logger
        err     *log.Logger
        writer  io.Writer
}

func NewLogger(p string) *Logger <span class="cov8" title="1">{
        writer := io.Writer(os.Stdout)
        logger := log.New(writer, p, log.Ldate|log.Ltime)

        return &amp;Logger{
                debug:   log.New(writer, "DEBUG: ", logger.Flags()),
                info:    log.New(writer, "INFO: ", logger.Flags()),
                warning: log.New(writer, "WARNING: ", logger.Flags()),
                err:     log.New(writer, "ERROR: ", logger.Flags()),
                writer:  writer,
        }
}</span>

// Create Non-Formatted Logs
func (l *Logger) Debug(v ...interface{}) <span class="cov0" title="0">{
        l.debug.Println(v...)
}</span>
func (l *Logger) Info(v ...interface{}) <span class="cov0" title="0">{
        l.info.Println(v...)
}</span>
func (l *Logger) Warn(v ...interface{}) <span class="cov0" title="0">{
        l.warning.Println(v...)
}</span>
func (l *Logger) Error(v ...interface{}) <span class="cov0" title="0">{
        l.err.Println(v...)
}</span>

// Create Format Enabled Logs
func (l *Logger) Debugf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.debug.Printf(format, v...)
}</span>
func (l *Logger) Infof(format string, v ...interface{}) <span class="cov0" title="0">{
        l.info.Printf(format, v...)
}</span>
func (l *Logger) Warnf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.warning.Printf(format, v...)
}</span>
func (l *Logger) Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        l.err.Printf(format, v...)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"

        "github.com/guicazaroto/learning-go/schemas"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func InitializePostgres() (*gorm.DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s user=%s port=%d password=%s dbname=%s", Environment.PostgresHost, Environment.PostgresUser, Environment.PostgresPort, Environment.PostgresPassword, Environment.PostgresDb)
        fmt.Println(dsn)
        db, err := gorm.Open(postgres.Open(dsn))
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error connecting to database")
                return nil, err
        }</span>

        <span class="cov0" title="0">err = db.AutoMigrate(&amp;schemas.User{}, &amp;schemas.Cleaner{}, &amp;schemas.Message{})

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error migrating database")
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "context"
        "fmt"
        "net/http"
        "path/filepath"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        aws_config "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/feature/s3/manager"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/aws/aws-sdk-go-v2/service/s3/types"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/guicazaroto/learning-go/config"
        "github.com/guicazaroto/learning-go/model"
        "github.com/guicazaroto/learning-go/repository"
        "github.com/guicazaroto/learning-go/schemas"
        "github.com/guicazaroto/learning-go/util"
)

func GetCleanerHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                city := c.Query("city")

                cleaners := repository.GetCleaners(city)

                if len(cleaners) == 0 </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusNotFound, "cleaners not found")
                        return
                }</span>
                <span class="cov8" title="1">cleanersResponse := []model.CleanerResponse{}
                for _, cleaner := range cleaners </span><span class="cov8" title="1">{
                        cleanersResponse = append(cleanersResponse, cleaner.ToResponse())
                }</span>
                <span class="cov8" title="1">util.SendSuccess(c, "get-all-cleaner", cleanersResponse)</span>
        }
}

func GetCleanerByIdHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                cleanerID := c.Param("id")
                cleaner := repository.GetCleanerById(cleanerID)
                if cleaner == nil </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusNotFound, "cleaner not found")
                        return
                }</span>
                <span class="cov8" title="1">util.SendSuccess(c, "get-cleaner-by-id", cleaner.ToResponse())</span>
        }
}

func GetCleanerMeByIdHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                cleanerID := c.GetString("id")
                cleaner := repository.GetCleanerById(cleanerID)
                if cleaner == nil </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusNotFound, "cleaner not found")
                        return
                }</span>
                <span class="cov8" title="1">util.SendSuccess(c, "get-cleaner-me-by-id", cleaner.ToResponseMe())</span>
        }
}

func CreateCleanerHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                request := model.CleanerRequest{}

                if err := c.BindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("body error: %v", err.Error())
                        util.SendError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>

                <span class="cov8" title="1">if err := request.Validate(); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("validation error: %v", err.Error())
                        util.SendError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>

                <span class="cov8" title="1">count := repository.GetCleanerByEmailAndCpf(request.Email, request.CPF)
                if count &gt; 0 </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusConflict, "already registered cleaner")
                        return
                }</span>

                <span class="cov8" title="1">cleaner := schemas.Cleaner{
                        UserInfos: schemas.User{
                                Name:     request.Name,
                                Email:    request.Email,
                                Password: util.HashString(request.Password),
                                Role:     "cleaner",
                                Active:   request.Active,
                        },
                        Telefone:       request.Telefone,
                        CPF:            request.CPF,
                        DataNascimento: request.DataNascimento,
                        Cep:            request.Cep,
                        Logradouro:     request.Logradouro,
                        Numero:         request.Numero,
                        Cidade:         request.Cidade,
                        Uf:             request.Uf,
                        Descricao:      request.Descricao,
                }

                if err := repository.CreateCleaner(&amp;cleaner); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("error creating opening: %v", err.Error())
                        util.SendError(c, http.StatusInternalServerError, "error creating opening on database")
                        return
                }</span>

                <span class="cov8" title="1">util.SendCreated(c, "create-cleaner", cleaner.ToResponse())</span>
        }
}

func UpdateCleanerHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                request := model.CleanerRequest{}
                cleanerID := c.GetString("id")

                cleaner := repository.GetCleanerById(cleanerID)
                if cleaner == nil </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusNotFound, "cleaner not found")
                        return
                }</span>

                <span class="cov8" title="1">if err := c.BindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>

                <span class="cov8" title="1">cleaner.UserInfos = schemas.User{
                        Name:      request.Name,
                        Active:    cleaner.UserInfos.Active,
                        Role:      cleaner.UserInfos.Role,
                        ImagemUrl: cleaner.UserInfos.ImagemUrl,
                        Password:  cleaner.UserInfos.Password,
                        Email:     cleaner.UserInfos.Email,
                        Model:     cleaner.Model,
                }
                cleaner.Cep = request.Cep
                cleaner.Cidade = request.Cidade
                cleaner.Descricao = request.Descricao
                cleaner.Logradouro = request.Logradouro
                cleaner.Numero = request.Numero
                cleaner.Telefone = request.Telefone
                cleaner.Uf = request.Uf

                if err := repository.SaveCleaner(cleaner); err != nil </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov8" title="1">util.SendSuccess(c, "update-cleaner", cleaner.ToResponseMe())</span>
        }
}

func DeleteCleanerHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                cleanerID := c.GetString("id")
                if err := repository.DeleteCleaner(cleanerID); err != nil </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov8" title="1">util.SendSuccess(c, "delete-cleaner", "Cleaner deleted successful")</span>
        }
}

func SendImgProfileHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                cleanerID := c.Param("id")
                cleaner := repository.GetCleanerById(cleanerID)
                if cleaner == nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusNotFound, "cleaner not found")
                        return
                }</span>
                <span class="cov0" title="0">if cleaner.UserInfos.ImagemUrl != "" </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusBadRequest, "image already sent")
                        return
                }</span>
                <span class="cov0" title="0">file, err := c.FormFile("file")
                if err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(file.Filename))

                if !config.AllowedExtensions[ext] </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusBadRequest, fmt.Sprintf("file type not allowed: %s", ext))
                        return
                }</span>

                <span class="cov0" title="0">cfg, err := aws_config.LoadDefaultConfig(context.TODO(), aws_config.WithRegion(config.Environment.AwsRegion))
                if err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">openedFile, err := file.Open()
                if err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">defer openedFile.Close()

                client := s3.NewFromConfig(cfg)

                fileName := fmt.Sprintf("%s%s", uuid.New().String(), ext)

                uploader := manager.NewUploader(client)
                result, err := uploader.Upload(context.TODO(), &amp;s3.PutObjectInput{
                        Bucket: aws.String(config.Environment.AwsImgProfileBucket),
                        Key:    aws.String(fileName),
                        Body:   openedFile,
                        ACL:    types.ObjectCannedACLPublicRead,
                })

                if err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if err := repository.UpdateImgUrlCleaner(cleaner, result.Location); err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">util.SendSuccess(c, "send-img-cleaner", gin.H{"message": "File uploaded successfully", "location": result.Location})</span>
        }
}

func UpdateImgProfileHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                cleanerID := c.GetString("id")
                cleaner := repository.GetCleanerById(cleanerID)
                if cleaner == nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusNotFound, "cleaner not found")
                        return
                }</span>
                <span class="cov0" title="0">file, err := c.FormFile("file")
                if err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(file.Filename))

                if !config.AllowedExtensions[ext] </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusBadRequest, fmt.Sprintf("file type not allowed: %s", ext))
                        return
                }</span>

                <span class="cov0" title="0">cfg, err := aws_config.LoadDefaultConfig(context.TODO(), aws_config.WithRegion(config.Environment.AwsRegion))
                if err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">openedFile, err := file.Open()
                if err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">defer openedFile.Close()

                client := s3.NewFromConfig(cfg)

                go func() </span><span class="cov0" title="0">{
                        fileUrl := strings.Split(cleaner.UserInfos.ImagemUrl, "/")
                        fileName := fileUrl[len(fileUrl)-1]

                        _, err = client.DeleteObject(context.TODO(), &amp;s3.DeleteObjectInput{
                                Bucket: aws.String(config.Environment.AwsImgProfileBucket),
                                Key:    aws.String(fileName),
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                util.SendError(c, http.StatusInternalServerError, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">waiter := s3.NewObjectNotExistsWaiter(client)
                        err = waiter.Wait(context.TODO(), &amp;s3.HeadObjectInput{
                                Bucket: aws.String(config.Environment.AwsImgProfileBucket),
                                Key:    aws.String(fileName),
                        }, *aws.Duration(time.Minute * 1))
                        if err != nil </span><span class="cov0" title="0">{
                                util.SendError(c, http.StatusInternalServerError, err.Error())
                                return
                        }</span>

                }()

                <span class="cov0" title="0">fileName := fmt.Sprintf("%s%s", uuid.New().String(), ext)

                uploader := manager.NewUploader(client)
                result, err := uploader.Upload(context.TODO(), &amp;s3.PutObjectInput{
                        Bucket: aws.String(config.Environment.AwsImgProfileBucket),
                        Key:    aws.String(fileName),
                        Body:   openedFile,
                        ACL:    types.ObjectCannedACLPublicRead,
                })

                if err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">if err := repository.UpdateImgUrlCleaner(cleaner, result.Location); err != nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusInternalServerError, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">util.SendSuccess(c, "update-img-cleaner", gin.H{"message": "File uploaded successfully", "location": result.Location})</span>
        }
}

func LoginCleanerHandler(repository repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                var creds struct {
                        Email    string `json:"email"`
                        Password string `json:"password"`
                }
                if err := c.BindJSON(&amp;creds); err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                        return
                }</span>
                <span class="cov8" title="1">cleaner := repository.GetCleanerByEmailAndPassword(creds.Email, creds.Password)
                if cleaner == nil </span><span class="cov8" title="1">{
                        util.SendError(c, http.StatusUnauthorized, "Unauthorized")
                        return
                }</span>

                <span class="cov8" title="1">tokenString, err := config.GenerateJWT(fmt.Sprint(cleaner.Id), "cleaner")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not generate token"})
                        return
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"token": tokenString})</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "github.com/guicazaroto/learning-go/config"
        "gorm.io/gorm"
)

var (
        logger *config.Logger
        db     *gorm.DB
)

func InitializeHandler() <span class="cov0" title="0">{
        logger = config.GetLogger("handler")
        db = config.GetDb()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

func PingHandler(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "message": "pong",
        })
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/guicazaroto/learning-go/model"
        "github.com/guicazaroto/learning-go/repository"
        "github.com/guicazaroto/learning-go/schemas"
        "github.com/guicazaroto/learning-go/util"
)

func GetMessageHandler(repository repository.MessageRepository) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                cleanerID := c.MustGet("id").(string)

                messages := repository.GetMessagesByCleanerId(cleanerID)

                messagesResponse := []model.MessageResponse{}
                for _, message := range messages </span><span class="cov0" title="0">{
                        messagesResponse = append(messagesResponse, message.ToResponse())
                }</span>
                <span class="cov0" title="0">util.SendSuccess(c, "get-all-messages", messagesResponse)</span>
        }
}

func CreateMessageHandler(repository repository.MessageRepository, repositoryCleaner repository.ICleanerRepositoryport) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                request := model.MessageRequest{}
                cleanerID := c.Param("id")
                if err := c.BindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("body error: %v", err.Error())
                        util.SendError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">if err := request.Validate(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("validation error: %v", err.Error())
                        util.SendError(c, http.StatusBadRequest, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">cleaner := repositoryCleaner.GetCleanerById(cleanerID)

                //var cleaner schemas.Cleaner
                if cleaner == nil </span><span class="cov0" title="0">{
                        util.SendError(c, http.StatusNotFound, "cleaner not found")
                        return
                }</span>

                <span class="cov0" title="0">message := schemas.Message{
                        CleanerId: cleaner.Id,
                        Message:   request.Message,
                        Telefone:  request.Telefone,
                        Nome:      request.Nome,
                        Email:     request.Email,
                }

                if err := repository.CreateMessage(&amp;message); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error creating opening: %v", err.Error())
                        util.SendError(c, http.StatusInternalServerError, "error creating opening on database")
                        return
                }</span>

                <span class="cov0" title="0">util.SendCreated(c, "create-cleaner-message", message.ToResponse())</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "github.com/guicazaroto/learning-go/schemas"
        "github.com/stretchr/testify/mock"
)

type mockCleanerRepository struct {
        mock.Mock
}

func (m *mockCleanerRepository) GetCleaners(city string) []schemas.Cleaner <span class="cov8" title="1">{
        args := m.Called(city)

        if cleaners, ok := args.Get(0).([]schemas.Cleaner); ok </span><span class="cov8" title="1">{
                return cleaners
        }</span>
        <span class="cov0" title="0">return []schemas.Cleaner{}</span>
}

func (m *mockCleanerRepository) GetCleanerById(cleanerID string) *schemas.Cleaner <span class="cov8" title="1">{
        args := m.Called(cleanerID)

        if cleaner, ok := args.Get(0).(*schemas.Cleaner); ok </span><span class="cov8" title="1">{
                return cleaner
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *mockCleanerRepository) GetCleanerByEmailAndCpf(email, cpf string) int64 <span class="cov8" title="1">{
        args := m.Called(email, cpf)

        if count, ok := args.Get(0).(int64); ok </span><span class="cov8" title="1">{
                return count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *mockCleanerRepository) CreateCleaner(cleaner *schemas.Cleaner) error <span class="cov8" title="1">{
        args := m.Called(cleaner)

        if err, ok := args.Get(0).(error); ok </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *mockCleanerRepository) SaveCleaner(cleaner *schemas.Cleaner) error <span class="cov8" title="1">{
        args := m.Called(cleaner)

        if err, ok := args.Get(0).(error); ok </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *mockCleanerRepository) DeleteCleaner(cleanerID string) error <span class="cov8" title="1">{
        args := m.Called(cleanerID)

        if err, ok := args.Get(0).(error); ok </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *mockCleanerRepository) GetCleanerByEmailAndPassword(email, password string) *schemas.Cleaner <span class="cov8" title="1">{
        args := m.Called(email, password)

        if cleaner, ok := args.Get(0).(*schemas.Cleaner); ok </span><span class="cov8" title="1">{
                return cleaner
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *mockCleanerRepository) UpdateImgUrlCleaner(cleaner *schemas.Cleaner, location string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "github.com/guicazaroto/learning-go/config"
        "github.com/guicazaroto/learning-go/router"
)

var (
        logger *config.Logger
)

func main() <span class="cov0" title="0">{
        logger = config.GetLogger("main")
        config.InitEnvs()
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error initializing config")
                return
        }</span>

        <span class="cov0" title="0">router.Initialize()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package model

import (
        "github.com/guicazaroto/learning-go/util"
)

type CleanerRequest struct {
        Telefone       string `json:"telefone"`
        CPF            string `json:"cpf"`
        DataNascimento string `json:"data_nascimento"`
        Cep            string `json:"cep"`
        Logradouro     string `json:"logradouro"`
        Numero         string `json:"numero"`
        Cidade         string `json:"cidade"`
        Uf             string `json:"uf"`
        Descricao      string `json:"descricao"`
        Name           string `json:"name"`
        Email          string `json:"email"`
        Password       string `json:"password"`
        Active         bool   `json:"active"`
}

func (r *CleanerRequest) Validate() error <span class="cov8" title="1">{
        if r.Name == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("name", "string")
        }</span>
        <span class="cov8" title="1">if r.Email == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("email", "string")
        }</span>
        <span class="cov8" title="1">if r.Password == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("password", "string")
        }</span>
        <span class="cov8" title="1">if r.Telefone == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("telefone", "string")
        }</span>
        <span class="cov8" title="1">if r.CPF == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("cpf", "string")
        }</span>
        <span class="cov8" title="1">if r.Cep == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("cep", "string")
        }</span>
        <span class="cov8" title="1">if r.Logradouro == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("logradouro", "string")
        }</span>
        <span class="cov8" title="1">if r.Cidade == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("cidade", "string")
        }</span>
        <span class="cov8" title="1">if r.Uf == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("uf", "string")
        }</span>
        <span class="cov8" title="1">if r.Descricao == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("descricao", "string")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package model

import "github.com/guicazaroto/learning-go/util"

type MessageRequest struct {
        Message  string `json:"message"`
        Telefone string `json:"telefone"`
        Nome     string `json:"nome"`
        Email    string `json:"email"`
}

func (r *MessageRequest) Validate() error <span class="cov8" title="1">{
        if r.Message == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("message", "string")
        }</span>
        <span class="cov8" title="1">if r.Telefone == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("telefone", "string")
        }</span>
        <span class="cov8" title="1">if r.Nome == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("nome", "string")
        }</span>
        <span class="cov8" title="1">if r.Email == "" </span><span class="cov8" title="1">{
                return util.ErrParamIsRequired("email", "string")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "github.com/guicazaroto/learning-go/schemas"
        "github.com/guicazaroto/learning-go/util"
        "gorm.io/gorm"
)

type CleanerRepository struct {
        Db *gorm.DB
}

type ICleanerRepositoryport interface {
        GetCleaners(city string) []schemas.Cleaner
        GetCleanerById(cleanerID string) *schemas.Cleaner
        GetCleanerByEmailAndCpf(email, cpf string) int64
        CreateCleaner(cleaner *schemas.Cleaner) error
        SaveCleaner(cleaner *schemas.Cleaner) error
        DeleteCleaner(cleanerID string) error
        GetCleanerByEmailAndPassword(email, password string) *schemas.Cleaner
        UpdateImgUrlCleaner(cleaner *schemas.Cleaner, location string) error
}

func NewCleanerRepository(db *gorm.DB) *CleanerRepository <span class="cov0" title="0">{
        return &amp;CleanerRepository{
                Db: db,
        }
}</span>

func (r *CleanerRepository) GetCleaners(city string) []schemas.Cleaner <span class="cov0" title="0">{
        var cleaners []schemas.Cleaner
        if city != "" </span><span class="cov0" title="0">{
                r.Db.Joins("UserInfos").Where("active = ?", true).Where("cidade = ?", city).Find(&amp;cleaners)
        }</span> else<span class="cov0" title="0"> {
                r.Db.Joins("UserInfos").Where("active = ?", true).Find(&amp;cleaners)
        }</span>
        <span class="cov0" title="0">return cleaners</span>
}

func (r *CleanerRepository) GetCleanerById(cleanerID string) *schemas.Cleaner <span class="cov0" title="0">{
        var cleaner *schemas.Cleaner
        result := r.Db.Preload("UserInfos").First(&amp;cleaner, cleanerID)
        if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return cleaner</span>
}

func (r *CleanerRepository) GetCleanerByEmailAndCpf(email, cpf string) int64 <span class="cov0" title="0">{
        var cleaner schemas.Cleaner
        var count int64
        r.Db.Joins("UserInfos").Where("email = ?", email).Or("cpf = ?", cpf).First(&amp;cleaner).Count(&amp;count)
        return count
}</span>

func (r *CleanerRepository) CreateCleaner(cleaner *schemas.Cleaner) error <span class="cov0" title="0">{
        if err := r.Db.Create(&amp;cleaner).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CleanerRepository) SaveCleaner(cleaner *schemas.Cleaner) error <span class="cov0" title="0">{
        if err := r.Db.Save(&amp;cleaner).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CleanerRepository) DeleteCleaner(cleanerID string) error <span class="cov0" title="0">{
        var cleaner schemas.Cleaner
        if err := r.Db.Unscoped().Delete(&amp;cleaner, cleanerID).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CleanerRepository) GetCleanerByEmailAndPassword(email, password string) *schemas.Cleaner <span class="cov0" title="0">{
        var cleaner schemas.Cleaner
        result := r.Db.Joins("UserInfos").Where("active = ?", true).Where("email = ?", email).Where("password = ?", util.HashString(password)).First(&amp;cleaner)
        if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;cleaner</span>
}

func (r *CleanerRepository) UpdateImgUrlCleaner(cleaner *schemas.Cleaner, location string) error <span class="cov0" title="0">{
        if err := r.Db.Model(&amp;cleaner.UserInfos).Update("ImagemUrl", location).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "github.com/guicazaroto/learning-go/schemas"
        "gorm.io/gorm"
)

type MessageRepository struct {
        Db *gorm.DB
}

func NewMessageRepository(db *gorm.DB) MessageRepository <span class="cov0" title="0">{
        return MessageRepository{
                Db: db,
        }
}</span>

func (m *MessageRepository) GetMessagesByCleanerId(cleanerID string) []schemas.Message <span class="cov0" title="0">{
        var messages []schemas.Message
        m.Db.Where("cleaner_id = ?", cleanerID).Find(&amp;messages)

        return messages
}</span>

func (r *MessageRepository) CreateMessage(message *schemas.Message) error <span class="cov0" title="0">{
        if err := r.Db.Create(&amp;message).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package router

import (
        "github.com/gin-gonic/gin"
        "github.com/guicazaroto/learning-go/util"
)

func Initialize() <span class="cov0" title="0">{
        r := gin.Default()
        r.Use(util.CORSMiddleware())

        initializeRoutes(r)
        r.Run()
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package router

import (
        "github.com/gin-gonic/gin"
        "github.com/guicazaroto/learning-go/config"
        "github.com/guicazaroto/learning-go/handler"
        "github.com/guicazaroto/learning-go/repository"
)

func initializeRoutes(router *gin.Engine) <span class="cov0" title="0">{
        handler.InitializeHandler()

        cleanerRepository := repository.NewCleanerRepository(config.GetDb())
        messageRepository := repository.NewMessageRepository(config.GetDb())

        v1 := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                v1.GET("/ping", handler.PingHandler)
                v1.GET("/cleaner/search", config.AuthTokenMiddleware(), handler.GetCleanerHandler(cleanerRepository))
                v1.GET("/cleaner/:id", config.AuthTokenMiddleware(), handler.GetCleanerByIdHandler(cleanerRepository))
                v1.GET("/cleaner/me", config.JWTMiddleware("cleaner"), handler.GetCleanerMeByIdHandler(cleanerRepository))
                v1.POST("/cleaner", config.AuthTokenMiddleware(), handler.CreateCleanerHandler(cleanerRepository))
                v1.PUT("/cleaner", config.JWTMiddleware("cleaner"), handler.UpdateCleanerHandler(cleanerRepository))
                v1.DELETE("/cleaner", config.JWTMiddleware("cleaner"), handler.DeleteCleanerHandler(cleanerRepository))
                v1.POST("/cleaner/login", config.AuthTokenMiddleware(), handler.LoginCleanerHandler(cleanerRepository))
                v1.POST("/cleaner/:id/img", config.AuthTokenMiddleware(), handler.SendImgProfileHandler(cleanerRepository))
                v1.PATCH("/cleaner/img", config.JWTMiddleware("cleaner"), handler.UpdateImgProfileHandler(cleanerRepository))

                v1.GET("/cleaner/message", config.JWTMiddleware("cleaner"), handler.GetMessageHandler(messageRepository))
                v1.POST("/cleaner/message/:id", config.AuthTokenMiddleware(), handler.CreateMessageHandler(messageRepository, cleanerRepository))

        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package schemas

import (
        "github.com/guicazaroto/learning-go/model"
        "gorm.io/gorm"
)

type Cleaner struct {
        gorm.Model
        Id             int64
        UserId         int64  `gorm:"not null"`
        UserInfos      User   `gorm:"foreignKey:UserId"`
        Telefone       string `gorm:"not null"`
        CPF            string `gorm:"not null,unique"`
        DataNascimento string `gorm:"not null"`
        Cep            string `gorm:"not null"`
        Logradouro     string `gorm:"size:100;not null"`
        Numero         string `gorm:"not null"`
        Cidade         string `gorm:"size:50;not null"`
        Uf             string `gorm:"size:2;not null"`
        Descricao      string `gorm:"size:200;not null"`
}

func (c *Cleaner) ToResponse() model.CleanerResponse <span class="cov8" title="1">{
        return model.CleanerResponse{
                Id:        c.Id,
                Name:      c.UserInfos.Name,
                Email:     c.UserInfos.Email,
                ImagemUrl: c.UserInfos.ImagemUrl,
                Telefone:  c.Telefone,
                Cidade:    c.Cidade,
                Uf:        c.Uf,
                Descricao: c.Descricao,
        }
}</span>

func (c *Cleaner) ToResponseMe() model.CleanerMeResponse <span class="cov8" title="1">{
        return model.CleanerMeResponse{
                Id:             c.Id,
                Name:           c.UserInfos.Name,
                Email:          c.UserInfos.Email,
                ImagemUrl:      c.UserInfos.ImagemUrl,
                Telefone:       c.Telefone,
                CPF:            c.CPF,
                DataNascimento: c.DataNascimento,
                Cep:            c.Cep,
                Logradouro:     c.Logradouro,
                Numero:         c.Numero,
                Cidade:         c.Cidade,
                Uf:             c.Uf,
                Descricao:      c.Descricao,
                CreatedAt:      c.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package schemas

import (
        "github.com/guicazaroto/learning-go/model"
        "gorm.io/gorm"
)

type Message struct {
        gorm.Model
        Id        int64
        CleanerId int64   `gorm:"not null"`
        Cleaner   Cleaner `gorm:"foreignKey:CleanerId"`
        Message   string  `gorm:"size:1000;not null"`
        Telefone  string  `gorm:"not null"`
        Nome      string  `gorm:"size:150;not null"`
        Email     string  `gorm:"not null"`
}

func (m *Message) ToResponse() model.MessageResponse <span class="cov8" title="1">{
        return model.MessageResponse{
                Id:        m.Id,
                Message:   m.Message,
                Telefone:  m.Telefone,
                CreatedAt: m.CreatedAt,
                Nome:      m.Nome,
                Email:     m.Email,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package util

import "github.com/gin-gonic/gin"

func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package util

import (
        "crypto/sha256"
        "fmt"
)

func HashString(str string) string <span class="cov8" title="1">{
        data := []byte(str)

        hasher := sha256.New()

        hasher.Write(data)

        hash := hasher.Sum(nil)

        return fmt.Sprintf("%x", hash)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package util

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
)

func SendError(ctx *gin.Context, code int, msg string) <span class="cov8" title="1">{
        ctx.Header("Content-type", "application/json")
        ctx.JSON(code, gin.H{
                "message":   msg,
                "errorCode": code,
        })
}</span>

func SendSuccess(ctx *gin.Context, op string, data interface{}) <span class="cov8" title="1">{
        ctx.Header("Content-type", "application/json")
        ctx.JSON(http.StatusOK, gin.H{
                "message": fmt.Sprintf("operation from handler: %s successfull", op),
                "data":    data,
        })
}</span>

func SendCreated(ctx *gin.Context, op string, data interface{}) <span class="cov8" title="1">{
        ctx.Header("Content-type", "application/json")
        ctx.JSON(http.StatusCreated, gin.H{
                "message": fmt.Sprintf("operation from handler: %s successfull", op),
                "data":    data,
        })
}</span>

func ErrParamIsRequired(name, typ string) error <span class="cov8" title="1">{
        return fmt.Errorf("param: %s (type: %s) is required", name, typ)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
